<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Typescript LINQ library</title>
    <link rel="stylesheet" href="index.css" type="text/css" />
  </head>
  <body>
    <h1>TS - A TypeScript module collection.</h1>
    <div id="navigation" style="width: 10em; vertical-align: top; position: fixed; top: 7em; left: 0.1em;">
      <ul>
        <li><a href="https://github.com/lord-saumagen/TS">Return to project</a></li>
        <li><a href="#Preface">Preface</a></li>
        <li><a href="#Introduction">Introduction</a></li>
        <li><a href="#Linq">LINQ</a></li>
        <li><a href="#Utils">Utils</a></li>
        <li><a href="#Exception">Exception</a></li>
        <li><a href="#Test">Test</a></li>
      </ul>
    </div>
    <div id="content" style="margin-left: 12em; vertical-align: top;">
      <div id="Preface">
        <h2>Preface</h2>
        In recent years I had to deal more and more with JavaScript as a web programmer. JavaScript was always part of the job, but it required more and more attention since it became popular to create single-page web application which are all build on top of Ajax. The same time the number of libraries which tried to circumvent the design flaws of the JavaScript language grew. There are also attempts to establisch a better language for client-side programming in web applications. Unfortunately they all failed.
        <br />
        As a programmer who relies on the object oriented programming paradigm, I have at least an ambivalent relationship to JavaScript. That programming language has 5 times
        more desing flaws than instructions. Even well established JavaScript libraries, which claim for themselfe to be professionel,
        look more like a result of a hacker contest than professionel code. Even worse, the language itself evolves with the speed of continental plates. There is no hope that
        the language will reach a mature state in the next 5000 years. Those which are responsible
        for the language specification 
        have also no intention to get rid of the ages old errors. Offically because they won&#39;t brake
        backward compatibility.<br />
        <br />
        Who ever came up with that lame excuse shall burn in hell for eterniyt.
        <br />
        <br />
        But then came <a href="http://en.wikipedia.org/wiki/Anders_Hejlsberg">Anders Hejlsberg</a>, my personal hero and inventor of <a href="http://en.wikipedia.org/wiki/TypeScript">TypeScript.</a><br />
        <br />
        He showed us a way out of the misery. He created a language which looks and feels almost like a real OO programming language.
        You do not longer have to deal with all the crap and hacks and well known errors to keep your JavaScript programs running. 
        Now you can program your script code just
        like you always did in C#. You also get full intellisense and error messages at compile
        time. At least when you use visual studio for
        your programming task.
        <br />
        <br />
        But how could Anders Hejlsberg establish a new cliend-side script language when all others (even google and god) failed. The
        simple answer is:<br />
        <br />
        &quot;Because he didn&#39;t even try.&quot;<br />
        <br />
        TypeScript code compiles ( or transpiles, if you like ) to JavaScript. This way your browser won&#39;t even notice that you are
        already a lightyear ahead of the lame script engine restriction. Someday, somebody should investigate why one of the
        worst programming languages man invented,&nbsp; was the only thing the browser vendors could agree on, during the dark ages of the
        browser war in the last millenium.
        <br />
        <br />
        Anders Hejlsberg did a great job and gave us lambda expressions, inheritance, something like a type system, typed function arguments, access modifiers and much much more. All that stuff you always wanted to have in JavaScript but didn&#39;t dare to ask for. Since the language is all new,&nbsp; he is still focused on developing the language itself and the compiler. So he didn&#39;t have time to create a full blown ecosystem around that language, like you may know from &quot;Phyton&quot; or &quot;Node.js&quot;. You can use existing javasript libraries in TypeScript with the help of TypeScript definition files (&quot;d.ts&quot;). Those &quot;d.ts&quot; files work much like header files in C or C++. They introduce the javscript library functions to TypeScript so that you can use them from within your TypeScript code. That gives you a headstart when you want to use TypeScript for serious coding, but don&#39;t have the time to wirte all necessary libraries by yourself. But you shouldn&#39;t settle for this. With TypeScript you have the tool to write much 
        more robust JavaScript code than ever before. My vision is, that there will come a time when those libraries are written in typescript in the first place. That will give us more robust libraries, code which is much easier to understand and you get also rid of the &quot;d.ts&quot; files. Event those which are not enlightened can still use your code, because after compiling it is plain JavaScript for them. That&#39;s the reason why I started this project.<br />
        <br />
        Since I&#39;m a great fan of LINQ in C#, it was a natural choice for me to start with a LINQ library. There are also some modules which are not LINQ specific at all, but build the foundation of a robust and eloquent coding style. Namely that are the type info function in the &quot;TS.Utils&quot; module and the exception classes.
        <br />
        <br />
        After all,&nbsp; I must say it is fun to write code in TypeScript. I had already lost my hope and didn&#39;t belive that there will one day fun
        in JavaScript programming. But the great visionary and master of superb programming languages disabused me.
        I take a deep bow in front of him and I hope you will have as much fun in using my library as I have in writing it.<br />
      </div>
      <div id="Introduction">
        <h2>Introduction</h2>
        This library is mainly a reprogrammed version of the default C# LINQ library in TypeScript. 
        The library may grow over time, but at the time of this writing the development is focused on the LINQ extensions.<br />
        <br />
        Below is a link to the description of the standard query operators as they are defined by microsoft:<br />
        <br />
        <a href="http://msdn.microsoft.com/en-us/library/bb397896.aspx">http://msdn.microsoft.com/en-us/library/bb397896.aspx</a><br />
        <br />
        There are other libraries available which offer the same functionality as this one. They may even be faster or offer
        more extensions than this one. But as far as I can tell, they were designed with different design goals in mind. Even if the 
        design
        goals are not explicitly named, you can tell hat by looking at their code.<br />
        <br />
        First of all, those libraries which I know are all written in plain JavaScript. But I would like to see more libraries and
        programs written in TypeScript in the first place. So I started my own project.<br />
        <br />
        Second, I like a <a href="https://cleancoders.com/">"Clean Code"</a> coding style. Unfortunately most JavaScript programmers don't bother for a clean coding style.
        They prefer the "Hacker Style" which makes it always a nighmare if it comes to a situation where you have to debug through their
        code.<br />
        <br />
        Third, I always vote for robustness over speed. All my functions implement an expensive parameter checking and fail gracefulley
        by throwing meaningfull exceptions.<br />
        <br />
        To make my point clear. There are JavaScript libraries which run much faster and there are libraries which offer a lot more 
        functionality. But if
        you need a robust and well designed library your are at the right place.

        <br />
        <br />
        All my public classes and functions got a code comment which shows up in the editor during typing. At leas if you use visual studio
        for development. That feature makes it a lot more easier to write code in JavaScript then you might expect. Check it out and you
        will never want to miss it.
        <br />
        <br />
        Even with that design goals in mind and extensive testing, there might be errors in this library. For that reason I would like to hear
        from you when you find one. Please drop a note at "lord.saumagen@gmail.com" with a full description of the error.
        <br />
        &nbsp;  
        <br />
        Since this is a work in progress, you will find modules, classes or functions which are not supposed to be used in business code, because of their immature state. Those functions which pass their unit tests are considered to be stable. Run the test suite in the &quot;Test&quot; directory to get a better understanding of which of the library functions are stable and can be used.
      </div>
      <div id="Linq">
        <h2>LINQ</h2>
        All classes, modules and interfaces which belong to the 'TS.Linq' namespace can be found in the corresponding subdirectory called 'Linq'.<br />
        <br />
        The extension functions are all defined in the 'TS.Linq.Extensions' module. The corresponding source file is the 'Extensions.ts' file in
        the
        'Linq' directory. The module functions resemble the public static functions defined in C#.
        <br />
        <br />
        Most of the extension functions are also bound to the 'TS.Linq.Enumerable' class which you can find in file 'Enumerable.ts'. This way you can
        use the fluent interface for the LINQ extensions which you may already know from C#.<br />
        <br />
        The table below shows all 
        LINQ extensions as defined by Microsoft and theire execution behavior. Those wich are marked green are considered complete implemented and tested.<br />
        Those wich are marked yellow are not yet implemented or not tested. 
        <br />
        Those which are marked read will never be implemented. Largely because of the missing type system in JavaScript.
        <br />
        <br />
        <a href="http://msdn.microsoft.com/en-us/library/bb882641.aspx">The default LINQ extension functions listed by Microsoft.</a>
        <br />
        <br />
        <table>
          <thead>
            <tr>
              <th colspan="3">Implemented LINQ extensions.
              </th>
            </tr>
            <tr>
              <th style="width: 12em;">Name</th>
              <th style="width: 12em;">Execution behavior</th>
              <th style="width: 12em;">Overloads</th>
            </tr>
          </thead>
          <tbody>
            <tr class="fullyImplemented">
              <td>
                aggregate
              </td>
              <td>
                Immediate execution
              </td>
              <td>
                1 overload
              </td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                all
              </td>
              <td>
                Immediate execution
              </td>
              <td>
                &nbsp;
              </td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                any
              </td>
              <td>
                Immediate execution
              </td>
              <td>
                1 overload
              </td>
            </tr>
            <tr class="notImplemented">
              <td>
                asEnumerable
              </td>
              <td>
                &nbsp;
              </td>
              <td>
                NOT IMPLEMENTED!&nbsp;&nbsp;See: 'fromArray'.
              </td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                average
              </td>
              <td>
                Immediate execution
              </td>
              <td>
                &nbsp;
              </td>
            </tr>
            <tr class="notImplemented">
              <td>
                cast
              </td>
              <td>
                &nbsp;
              </td>
              <td>
                NOT IMPLEMENTED!&nbsp;&nbsp;See: 'toArray'.
              </td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                concat
              </td>
              <td>
                Deferred execution
              </td>
              <td>
                &nbsp;
              </td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                contains
              </td>
              <td>
                Immediate execution
              </td>
              <td>
                1 overload
              </td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                count
              </td>
              <td>
                Immediate execution
              </td>
              <td>
                1 overload
              </td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                defaultIfEmpty
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                distinct
              </td>
              <td>
                Deferred execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                elementAt
              </td>
              <td>
                Immediate execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                elementAtOrDefault
              </td>
              <td>
                Immediate execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                empty
              </td>
              <td>
                Immediate execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                except
              </td>
              <td>
                Deferred execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                first
              </td>
              <td>
                Immediate execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                firstOrDefault
              </td>
              <td>
                Immediate execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                groupBy
              </td>
              <td>
                Deferred execution
              </td>
              <td>
               3 overloads
              </td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                groupJoin
              </td>
              <td>
                Deferred execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                intersect
              </td>
              <td>
                &nbsp;Deferred execution</td>
              <td>
                1 overload
              </td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                join
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                last
              </td>
              <td>
                Immediate execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                lastOrDefault
              </td>
              <td>
                Immediate execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                max
              </td>
              <td>
                Immediate execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                min
              </td>
              <td>
                Immediate execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="notImplemented">
              <td>
                ofType
              </td>
              <td>
                &nbsp;
              </td>
              <td>
                NOT IMPLEMENTED!
              </td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                orderBy
              </td>
              <td>
                Deferred execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                orderByDescending
              </td>
              <td>
                Deferred execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                range
              </td>
              <td>
               Immediate execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                repeat
              </td>
              <td>
                Immediate execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                reverse
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                select
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                selectMany
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                sequenceEqual
              </td>
              <td>
                Immediate execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                single
              </td>
              <td>
                Immediate execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                singleOrDefault
              </td>
              <td>
                Immediate execution
              </td>
              <td>1 overload</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                skip
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                skipWhile
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                sum
              </td>
              <td>
                Immediate execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                take
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                takeWhile
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                thenBy
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                thenByDescending
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                toArray
              </td>
              <td>
                Immediate execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="notImplemented">
              <td>
                toDictionary
              </td>
              <td>
                &nbsp;
              </td>
              <td>
                NOT IMPLEMENTED!
              </td>
            </tr>
            <tr class="notImplemented">
              <td>
                toList
              </td>
              <td>
                &nbsp;
              </td>
              <td>
                NOT IMPLEMENTED!
              </td>
            </tr>
            <tr class="notImplemented">
              <td>
                toLookup
              </td>
              <td>
                &nbsp;
              </td>
              <td>
                NOT IMPLEMENTED!
              </td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                union
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                where
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <p>
          There are also some extensions which are no standard query operators. The extension function &quot;fromArray&quot; is essential for the use of the &quot;TS.Linq&quot; module. The others are useful for test scenarios. The &quot;cycle&quot; and &quot;random&quot; extension functions are no query operators at all. They are generators and should only be used in conjuntion with a following &quot;take&quot; operator to limit their output. Otherwise you will run into a memory leak.&nbsp;
        </p>
        <table>
          <thead>
            <tr>
              <th colspan="3">Additional extensions</th>
            </tr>
            <tr>
              <th style="width: 12em;">Name</th>
              <th style="width: 12em;">Execution behavior</th>
              <th style="width: 12em;"></th>
            </tr>
          </thead>
          <tbody>
            <tr class="fullyImplemented">
              <td style="width: 12em;">
                cycle
              </td>
              <td style="width: 12em;">
                Deferred execution
              </td>
              <td style="width: 12em;">&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                fromArray
              </td>
              <td>
                Immediate execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                random
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
            <tr class="fullyImplemented">
              <td>
                shuffle
              </td>
              <td>
                Deferred execution
              </td>
              <td>&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <h3>How to use
        </h3>
        If you want to use the extension functions you have to create an instance of "Enumerable&lt;T&gt" in the first place. You get one by casting
        an array of any type into an enumerable by calling the function "fromArray" which is defined in the "TS.Linq.Extensions" module. Since there 
        are no other collection types available in JavaScript, there is also no other type you could cast to an enumerable.
        <br />
        <br />
        <code>newEnumerable = TS.Linq.Extensions.fromArray([anyArray]);
        </code>
        <br />
        <br />
        That function is also assigned to the "Enumerable&lt;T&gt" class as a static function, you can call that function from that class or any
        instance of that class too. 
        <br />
        <br />
        <code>newEnumerable1 = TS.Linq.Enumerable.fromArray([anyArray]);
        </code>
        <br />
        <br />
        <code>newEnumerable2 = newEnumerable1.fromArray([anyArray]);
        </code>
        <br />
        <br />
        Once you have an enumerable, you can use the LINQ extension functions to work on that enumerable. You can either call the static extension functions
        which require an enumerable as argument, or you can use the fluent interface on the enumerable instance.
        <br />
        <br />
        Here is an example which calls a static function:
        <br />
        <br />
        <code>_testResultCarEnumerable = TS.Linq.Extensions.distinct(_testInputCarEnumerable, (first, second) =&gt; first.name == second.name);
        </code>
        <br />
        <br />
        The same call using the fluent interface:
        <br />
        <br />
        <code>_testResultCarEnumerable = _testInputCarEnumerable.distinct((first, second) => first.name == second.name);
        </code>
        <br />
        <br />
        If you are familiar with LINQ in C#, there is nothing new to you. The function above retuns an enumerable as a result to the call of "distinct".
        You can go on with that enumerable and use other LINQ extension functions on it, or you can call the "toArray" function wich casts the result into
        a JavaScript array of the result type. 
        From that moment on, you can work with the result array as you would with any other JavaScript array.<br />
        <br />
        So that&#39;s all to say about this library. If you are curious about the deffered execution behavior or if you are new to LINQ at all you should read about it in one of the online tutorials or at <a href="https://social.msdn.microsoft.com/search/en-US?query=linq">MSDN</a>. There is also a vast amount of books which cover this topic.&nbsp;

      </div>
      <div id="Utils">
        <h2>Utils</h2>
        All classes, modules and interfaces which belong to the 'TS.Utils' namespace can be found in the corresponding subdirectory called 'Utils&#39;.<br />
        <br />
        The 'Utils' module hosts all the functions and classes which have a general purpose but no common problem domain. They do very different things 
        but have in common that they come in handy at mundane programming tasks.
        <br />
        <br />
        You will find the following functions, enums and classes at the &#39;TS.Utils&#39; module level.<br />
        <br />

        <table>
          <tbody>
            <tr>
              <th colspan="2" style="text-align: left;">Classes:</th>
            </tr>
            <tr>
              <td>
                <code>TS.Utils.TypeInfo</code>
              </td>
              <td>
                A static class which offers a bunch of functions for type detection of javascript objects. 
              </td>
            </tr>
            <tr>
              <th colspan="2" style="text-align: left;">Enums:</th>
            </tr>
            <tr>
              <td>
                <code>TS.Utils.TypeEnum</code>
              </td>
              <td>
                An enumeration which lists all detectable JavaScript types.
              </td>
            </tr>
            <tr>
              <th colspan="2" style="text-align: left;">Functions:</th>
            </tr>
            <tr>
              <td>
                <code>compactArray(arr: Array&lt;any&gt;): Array&lt;any&gt;
                </code>
              </td>
              <td>
                The functions takes a sparse array of any type and returns a compacted array of the same type.
              </td>
            </tr>
            <tr>
              <td>
                <code>createGUID(): string
                </code>
              </td>
              <td>
                Creates a version 4 random GUID and returns it as string in it's canonical representation.
              </td>
            </tr>
            <tr>
              <td>
                <code>fillLeft(source: string, fillChar: string, length: number): string
                </code>
              </td>
              <td>
                The functions takes a string and a fill character and returns a string which is filled up with the fill character from the left, until the total number of characters matches the number specified in length.
              </td>
            </tr>
            <tr>
              <td style="width: 30em;">
                <code>HTMLCollectionToArray(collection): Array&lt;HTMLElement&gt;
                </code>
              </td>
              <td>
                The functions takes a HTML collection and returns that collection as an array of HTMLElements. 
              </td>
            </tr>
            <tr>
              <td>
                <code>normalizePath(path: string): string
                </code>
              </td>
              <td>
                The functions takes a path string and returnes a string where every occurence of a '\' is replaced by a '/'.
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <div id="Exception">
        <h2>Exception</h2>
        The &#39;TS.Exception&#39; class and some derived classes can be found in the subdirectory called &#39;Exception&#39; in file &#39;Exception.ts&#39;.<br />
        <br />
        The 'TS.Exception&#39; 
        class is a substitute for the poor JavaScript &#39;Error&#39; classes which are part of the language specification in JavaScript. So your are forced to use one of those classes to signal an exceptions, even if none of them is appropriate. The &#39;TS.Exception&#39; class is an attempt to introduce the power and flexibility of the exception system use in C#, into TypeScript.
        <br />
        <br />
        Since TypeScript builds on JavaScript, and JavaScript doesn&#39;t offer a type system, it&#39;s also impossible to determine a specific exeption type. To circumvent that problem you should follow a design convention when creating your own exception classes derived from &#39;TS.Exception&#39; or it&#39;s subclasses.<br />
        <br />
        Before I will explain the convention, let&#39;s have a look at the definition of the &#39;TS.Exception&#39; class.
        <br />
        <pre>
export class Exception implements Error
{
  private _message: string;
  private _innerException: Exception;

  public get innerException(): Exception
  {
    return this._innerException;
  }

  /**
  *  @implemnts
  *    Error.message
  */
  public get message(): string
  {
    return this._message;
  }

  /**
  *  @implemnts
  *    Error.name
  */
  public get name(): string
  {
    return this.type;
  }

  public get type(): string
  {
    return "TS.Exception";
  }

  /**
  *  @constructs
  *    TS.Exception
  */
  constructor(message?: string, innerException?: Exception)
  {
    this._message = (message) ? message : "";
    this._innerException = (innerException) ? innerException : null;
  }

  /**
  *  @overwrite
  *    Object.toString
  */
  public toString(): string
  {
    return this.type + ((this.message.length > 0) ? " :: " + this.message : "");
  }

}//END class

        </pre>
        As you can see, the 'TS.Exception' class implements the 'Error' interface. 
        The interface is defined as follows.<br />
        <br />
        <pre>
interface Error 
{
  name: string;
  message: string;
}
</pre>
        That means that the 'TS.Exception' class and all of it's 
        descendants have a &#39;name&#39; and a &#39;message&#39; property.&nbsp; The properties are implemented as read only properties. They can only be set once in the constructor.&nbsp; The class also implements a constant &#39;type&#39; property which holds the fully qualified type name of the current class as string. The class overwrites the &#39;toString&#39; methode inherrited from the class &#39;Object&#39;. This method returns a string wich consists of the type name as defined in property &#39;type&#39; and if available the message as defined in property &#39;message&#39; separated by the following string: &quot; :: &quot;.<br />
        <br />
        There is nothing special with this class, except that it gives you the freedom to create exception classes for your own purpose by deriving from &#39;TS.Exception&#39; or one of it&#39;s derivates. There are only two rules you should follow. <br />
        <br />
        1. Overwrite the inherrited &#39;type&#39; property with the fully qualified name of your derived class.<br />
        2. Call the constructor of the base class in the constructor of your derived class. <br />
        <br />
        When you open the 'Exception.ts' file, you will notice that there is more than one exception class defined in this file. The next in order of occurence is the 'ArgumentException' class. 
        You can see the definition of that file below.
        As you can see, the &#39;type&#39; property overwrites the inherrited &#39;type&#39; property and the constructor of the base class is called in the constructor.&nbsp;
        <br />
        <br />
        <pre>
export class ArgumentException extends Exception
{
  private _argumentName: string;
  private _argumentValue: any;

  /**
  *  @overwrite
  */
  public get type(): string
  {
    return "TS.ArgumentException";
  }

  get argumentName(): string
  {
    return this._argumentName;
  }

  get argumentValue(): any
  {
    return this._argumentValue;
  }

  /**
  *  @constructs
  */
  constructor(argumentName: string, argumentValue: any, message?: string, innerException?: Exception)
  {
    super(message, innerException);
    this._argumentName = (argumentName) ? argumentName : "";
    this._argumentValue = argumentValue;
  }

}//END class

        </pre>
        Now you may ask yourself what&#39;s the advantage of this construction at all, because you could also use an &#39;Error&#39; class or one of the six other errors defined in the JavaScript language definition. Of course you can. But if those classes doesn&#39;t fit your needs, you will have to create your own exception system anyway. So you can also stick with this system from the beginning and don&#39;t have to bother with the poor implementation in JavaScript.
        <br />
        <br />
        It makes is also easier to determine the type fo an exception. Lets say you wrote an exception handler but you are only interested in those exceptions you are able to handel in your handler. Your code might look like this.<br />
        <br />
        <pre>
 try
{
  //Any expression or statement that might throw en exception.
}//END try
catch (ex)
{
  switch ((&lt;TS.Exception&gt; ex).type)
  {
    case "TS.ArgumentNullException":
      {
        //Handle the 'ArgumentNullException'.
      }
    case "TS.IndexOutOfRangeException":
      {
        //Handle the 'IndexOutOfRangeException'.
      }
    default:
      {
        //Rethrow the exception if not handled.
        throw ex;
      }
  }//END switch
}//END catch        
        </pre>
        You see, this way it is pretty easy to filter exceptions by it's type. 
        You don&#39;t have to parse the message string to determine the exception type. Even if the message is empty, you still can tell what kind of exceptions you got by looking at the &#39;type&#39; attribute.<br />
        <br />
        If you want to see a working example of specialised exceptions classes an how they are used, take a look into the file &#39;Extensions.ts&#39; in the &#39;Linq&#39; subdirectory. You will find the exceptions classes which are specific to the &#39;TS.Linq.Extension&#39; module and have no meaning outsider of that context.</div>
      <div id="Test">
        <h2>Test</h2>
        You will find the unit tests fore each module in the subdirectory 'Test'. All modules have a corresponding TypeScript file in this directory. Some have also a corresponding 
        file written in plain JavaScript. The naming rule for the unit tests is as follows:
        <br /><br />
        "TS_" + [Fully Qualified Module Name] + "_test.js" for a test file wirtten in TypeScript or, <br />
        "TS_" + [Fully Qualified Module Name] + "_test_plain.js" for a test fiel written in plain JavaScript. <br />
        <br />
        The namespace / module separator in the fully qualified module name is the '_'. <br />
        <br />
        There is also a HTML page for each module following the same naming convention. That HTML page is used to start the unit tests in your browser. I chose the <a href="http://qunitjs.com/">QUnit</a> testing framework for this project.
        Running a unit test is only a matter of opening the corresponding HTML page in your Browser.<br />
        There is also a HTML page called &quot;TestSuite.html&quot; which will run all unit test at once.
        <br />
        <br />
        The subdirectory &quot;Data&quot; in the &quot;Test&quot; directory holds the test data for the unit tests.<br />
        <br />
        The test files in plain JavaScript need a little explanation. Some tests regarding the error handling of the modules wasn&#39;t realizeable in TypeScript. The simple reason for that is, TypeScript doesn&#39;t allow you to write as erroneous code as you can write in plain JavaScript. So I had to write those tests in plain JavaScript. </div>
    </div>
  </body>
</html>
